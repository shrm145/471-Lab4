module instructionFetch(instruction, Jump, JR, Branch, negative, imm16, regRS);
	output [31:0] instruction;
	input Jump, JR, Branch, negative;
	input [15:0] imm16;
	input [29:0] regRs; // not including last 2 bits of regRS

	wire PCnotJR; 
	wire [29:0] PC, constCtrl, PCnoJump, PCJump;

// determines value of PC. If JR set equal to ALUoutput, otherwise keep previous PC value
	mux2_1_30Bit detPCMux (.out(PCnotJR), .in0({PC}), .in1(regRS), .sel(JR));
	
	// determines control for valToAdderMux. Positive if branching and Reg[rs] is negative 
	and #50 (valToAdderCtrl, Branch, negative);
	
	// NEED SIGN EXTEND HERE
	
	// determines value sent to added to PC. 
	mux2_1_30Bit valToAdderMux (.out(constCtrl), .in0(30'b0), .in1({16'b0, imm16}), .sel(valToAdderCtrl));
	
	
	// 30 bit adder that updates program counter
	adder30Bit adder30 (.out(PCnoJump), .cin(1'b1), .in0(PC), .in1(constCtrl));
	
	// determines PC based on whether the instruction is a jump
	mux2_1_30Bit jumpMux (.out(PC), .in0(PCnoJump), .in1({PC[29:26], jumpTarget}), .sel(Jump));
	
	//Instruction memory, gets instruction at PC
	InstructionMem getInstr (.instruction, .address({PC, 2'b00}));
	
	//GET VALUES FROM FETCH: Rs, Rt, imm16 etc
	controls calcCtrls (.Branch, .Jump, .JR, .ALUSource, .ALUControl, .RegWrite, .MemWrite, .MemToReg, .RegDest, .instruction);
	
	endmodule 
	
	